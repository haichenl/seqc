function value = GetGaussianCartesianMatrix(obj, ...
    atomTypeA, valenceOrbitalA, gaussianExponentA, xyzA,...
    atomTypeB, valenceOrbitalB, gaussianExponentB, xyzB,...
    rAB, overlapSASB, axis)
gauPlusAB = gaussianExponentA+gaussianExponentB;
gauMultAB = gaussianExponentA*gaussianExponentB;
dxyz = xyzA - xyzB;
if(valenceOrbitalA == OrbitalType.s && valenceOrbitalB == OrbitalType.s)
    value = gaussianExponentA*xyzA(axis) + gaussianExponentB*xyzB(axis);
    value = value / gauPlusAB;
    value = value * overlapSASB;
elseif( (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.px) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.py) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.pz) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.dxy) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.dyz) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.dxxyy) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 1 && valenceOrbitalB == OrbitalType.dzz) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.px) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.py) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.dxxyy) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 2 && valenceOrbitalB == OrbitalType.dzz) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.px) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.py) || ...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.dxxyy) ||...
        (valenceOrbitalA == OrbitalType.s && axis == 3 && valenceOrbitalB == OrbitalType.dzz) )
    if(axis == 1)
        pOrbital = OrbitalType.px;
    elseif(axis == 2)
        pOrbital = OrbitalType.py;
    elseif(axis == 3)
        pOrbital = OrbitalType.pz;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz,...
        rAB,...
        overlapSASB);
    overlapAOs2 = obj.GetGaussianOverlapAOs(atomTypeA,...
        pOrbital, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = overlapAOs2/(2.0*sqrt(gaussianExponentA))+xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.px    && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.py    && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.pz    && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 1 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.px    && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.py    && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.pz    && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 2 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.px    && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.py    && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.pz    && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.s) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 3 && valenceOrbitalB == OrbitalType.s) )
    if(axis == 1)
        pOrbital = OrbitalType.px;
    elseif(axis == 2)
        pOrbital = OrbitalType.py;
    elseif(axis == 3)
        pOrbital = OrbitalType.pz;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    overlapAOs2 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        pOrbital, ...
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    value = overlapAOs2/(2.0*sqrt(gaussianExponentB))+xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == valenceOrbitalA) )
    temp1 = gaussianExponentA*xyzA(axis) + gaussianExponentB*xyzB(axis);
    temp2 = gaussianExponentA*xyzA(axis) - gaussianExponentA*xyzB(axis);
    temp3 = gaussianExponentB*xyzA(axis) - gaussianExponentB*xyzB(axis);
    value = 0.5*(temp1+temp2-temp3);
    value = value - temp1*temp2*temp3/gauPlusAB;
    value = value * 4.0*sqrt(gauMultAB)/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == valenceOrbitalA) )
    if(valenceOrbitalA == OrbitalType.px)
        piDirection = 1;
    elseif(valenceOrbitalA == OrbitalType.py)
        piDirection = 2;
    elseif(valenceOrbitalA == OrbitalType.pz)
        piDirection = 3;
    end
    temp1 = gaussianExponentA*xyzA(piDirection) - gaussianExponentA*xyzB(piDirection);
    temp2 = gaussianExponentB*xyzA(piDirection) - gaussianExponentB*xyzB(piDirection);
    value = 0.5 - temp1*temp2/gauPlusAB;
    value = value * gaussianExponentA*xyzA(axis) + gaussianExponentB*xyzB(axis);
    value = value * 4.0*sqrt(gauMultAB)/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == OrbitalType.py) )
    if(valenceOrbitalA == OrbitalType.px)
        piDirectionA = 1;
    elseif(valenceOrbitalA == OrbitalType.py)
        piDirectionA = 2;
    elseif(valenceOrbitalA == OrbitalType.pz)
        piDirectionA = 3;
    end
    temp1 = gaussianExponentA*xyzA(axis) + gaussianExponentB*xyzB(axis);
    temp2 = gaussianExponentA*xyzA(axis) - gaussianExponentA*xyzB(axis);
    value = 0.5 + temp1*temp2/gauPlusAB;
    value = value * gaussianExponentB*xyzA(piDirectionA) - gaussianExponentB*xyzB(piDirectionA);
    value = value * -4.0*sqrt(gauMultAB)/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
elseif( (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == OrbitalType.py) )
    if(valenceOrbitalB == OrbitalType.px)
        piDirectionB = 1;
    elseif(valenceOrbitalB == OrbitalType.py)
        piDirectionB = 2;
    elseif(valenceOrbitalB == OrbitalType.pz)
        piDirectionB = 3;
    end
    temp1 = gaussianExponentA*xyzA(axis) + gaussianExponentB*xyzB(axis);
    temp2 = gaussianExponentB*xyzA(axis) - gaussianExponentB*xyzB(axis);
    value = 0.5 - temp1*temp2/gauPlusAB;
    value = value * gaussianExponentA*xyzA(piDirectionB) - gaussianExponentA*xyzB(piDirectionB);
    value = value * 4.0*sqrt(gauMultAB)/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == OrbitalType.pz) )
    if(valenceOrbitalA == OrbitalType.px)
        piDirectionA = 1;
    elseif(valenceOrbitalA == OrbitalType.py)
        piDirectionA = 2;
    elseif(valenceOrbitalA == OrbitalType.pz)
        piDirectionA = 3;
    end
    if(valenceOrbitalB == OrbitalType.px)
        piDirectionB = 1;
    elseif(valenceOrbitalB == OrbitalType.py)
        piDirectionB = 2;
    elseif(valenceOrbitalB == OrbitalType.pz)
        piDirectionB = 3;
    end
    temp1 = gaussianExponentB*xyzA(piDirectionA) - gaussianExponentB*xyzB(piDirectionA);
    temp2 = gaussianExponentA*xyzA(axis)         + gaussianExponentB*xyzB(axis);
    temp3 = gaussianExponentA*xyzA(piDirectionB) - gaussianExponentA*xyzB(piDirectionB);
    value = -4.0*sqrt(gauMultAB)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * temp1*temp2*temp3;
    value = value * overlapSASB;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == OrbitalType.dzx) )
    if(valenceOrbitalB == OrbitalType.dxy)
        if(axis == 1)
            anotherAxis = 2;
        else
            anotherAxis = 1;
        end
    elseif(valenceOrbitalB == OrbitalType.dyz)
        if(axis == 2)
            anotherAxis = 3;
            
        else
            anotherAxis = 2;
        end
    elseif(valenceOrbitalB == OrbitalType.dzx)
        if(axis == 3)
            anotherAxis = 1;
            
        else
            anotherAxis = 3;
        end
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5*gaussianExponentA*dxyz(axis)...
        -gaussianExponentB*dxyz(axis)...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *dxyz(axis)*dxyz(axis)*dxyz(axis)/gauPlusAB;
    value = value * 8.0*gaussianExponentA*sqrt(gaussianExponentA)...
        *gaussianExponentB*dxyz(anotherAxis)*overlapSASB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxy && axis == 1 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 2 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 2 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 3 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 3 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 1 && valenceOrbitalB == OrbitalType.px) )
    if(valenceOrbitalA == OrbitalType.dxy)
        if(axis == 1)
            anotherAxis = 2;
        else
            anotherAxis = 1;
        end
    elseif(valenceOrbitalA == OrbitalType.dyz)
        if(axis == 2)
            anotherAxis = 3;
        else
            anotherAxis = 2;
        end
    elseif(valenceOrbitalA == OrbitalType.dzx)
        if(axis == 3)
            anotherAxis = 1;
        else
            anotherAxis = 3;
        end
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz,...
        rAB,...
        overlapSASB);
    value = 0.5*gaussianExponentB*dxyz(axis)...
        -gaussianExponentA*dxyz(axis)...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *dxyz(axis)*dxyz(axis)*dxyz(axis)/gauPlusAB;
    value = value * 8.0*gaussianExponentB*sqrt(gaussianExponentB)*gaussianExponentA...
        *dxyz(anotherAxis)*overlapSASB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == OrbitalType.dzx) )
    if(axis == 1)
        anotherAxis1 = 2;
        anotherAxis2 = 3;
    elseif(axis == 2)
        anotherAxis1 = 1;
        anotherAxis2 = 3;
    elseif(axis == 3)
        anotherAxis1 = 1;
        anotherAxis2 = 2;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,... ...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5+gaussianExponentB*gaussianExponentB*dxyz(axis)*dxyz(axis)/gauPlusAB;
    value = value * 8.0*gaussianExponentA*gaussianExponentA*sqrt(gaussianExponentA)...
        *gaussianExponentB*overlapSASB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * dxyz(anotherAxis1)*dxyz(anotherAxis2);
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxy && axis == 3 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 1 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 2 && valenceOrbitalB == OrbitalType.py) )
    if(axis == 1)
        anotherAxis1 = 2;
        anotherAxis2 = 3;
    elseif(axis == 2)
        anotherAxis1 = 1;
        anotherAxis2 = 3;
    elseif(axis == 3)
        anotherAxis1 = 1;
        anotherAxis2 = 2;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,... ...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5+gaussianExponentA*gaussianExponentA*dxyz(axis)*dxyz(axis)/gauPlusAB;
    value = value * 8.0*gaussianExponentB*gaussianExponentB*sqrt(gaussianExponentB)...
        *gaussianExponentA*overlapSASB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * dxyz(anotherAxis1)*dxyz(anotherAxis2);
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 2 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.px && axis == 3 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 1 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 3 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 1 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.pz && axis == 2 && valenceOrbitalB == dzz) )
    if( (valenceOrbitalA == OrbitalType.py && axis == 1) ||...
            (valenceOrbitalA == OrbitalType.px && axis == 2) )
        dOrbital = OrbitalType.dxy;
    elseif( (valenceOrbitalA == OrbitalType.py && axis == 3) ||...
            (valenceOrbitalA == OrbitalType.pz && axis == 2) )
        dOrbital = OrbitalType.dyz;
    elseif( (valenceOrbitalA == OrbitalType.px && axis == 3) ||...
            (valenceOrbitalA == OrbitalType.pz && axis == 1) )
        dOrbital = OrbitalType.dzx;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    overlapAOs2 = obj.GetGaussianOverlapAOs(atomTypeA,......
        dOrbital, ...
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    value = overlapAOs2/(2.0*sqrt(gaussianExponentA))+xyzA(axis)*overlapAOs1;
    
    
elseif( (valenceOrbitalA == OrbitalType.dxy   && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 3 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 1 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dxy   && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 3 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 1 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 3 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 1 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 2 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 3 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 1 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 3 && valenceOrbitalB == OrbitalType.py) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 1 && valenceOrbitalB == OrbitalType.pz) ||...
        (valenceOrbitalA == OrbitalType.dzz   && axis == 2 && valenceOrbitalB == OrbitalType.pz) )
    if( (valenceOrbitalB == OrbitalType.py && axis == 1) ||...
            (valenceOrbitalB == OrbitalType.px && axis == 2) )
        dOrbital = OrbitalType.dxy;
    elseif( (valenceOrbitalB == OrbitalType.py && axis == 3) ||...
            (valenceOrbitalB == OrbitalType.pz && axis == 2) )
        dOrbital = OrbitalType.dyz;
    elseif( (valenceOrbitalB == OrbitalType.px && axis == 3) ||...
            (valenceOrbitalB == OrbitalType.pz && axis == 1) )
        dOrbital = OrbitalType.dzx;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    overlapAOs2 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        dOrbital, ...
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    value = overlapAOs2/(2.0*sqrt(gaussianExponentB))+xyzB(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == dxxyy)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5-2.0*gauMultAB*(dxyz(1)*dxyz(1))/gauPlusAB;
    value = value + 0.5*(gaussianExponentA*gaussianExponentA)*((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB;
    value = value + (gauMultAB*dxyz(1)...
        *gauMultAB*dxyz(1))...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(gauPlusAB*gauPlusAB);
    value = value * 4.0*sqrt(gaussianExponentA)*gaussianExponentB/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.px)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,......
        valenceOrbitalA, ......
        gaussianExponentA, ......
        atomTypeB, ......
        valenceOrbitalB, ......
        gaussianExponentB,......
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5-2.0*gauMultAB*(dxyz(1)*dxyz(1))/gauPlusAB;
    value = value + 0.5*(gaussianExponentB*gaussianExponentB)*((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB;
    value = value + (gauMultAB*dxyz(1)...
        *gauMultAB*dxyz(1))...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(gauPlusAB*gauPlusAB);
    value = value * 4.0*sqrt(gaussianExponentB)*gaussianExponentA/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == dxxyy)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5-2.0*gauMultAB*(dxyz(2)*dxyz(2))/gauPlusAB;
    value = value + 0.5*(gaussianExponentA*gaussianExponentA)*((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/gauPlusAB;
    value = value + (gauMultAB*dxyz(2)...
        *gauMultAB*dxyz(2))...
        *((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/(gauPlusAB*gauPlusAB);
    value = value * -4.0*sqrt(gaussianExponentA)*gaussianExponentB/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.py)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5-2.0*gauMultAB*(dxyz(2)*dxyz(2))/gauPlusAB;
    value = value + 0.5*(gaussianExponentB*gaussianExponentB)*((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/gauPlusAB;
    value = value + (gauMultAB*dxyz(2)...
        *gauMultAB*dxyz(2))...
        *((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/(gauPlusAB*gauPlusAB);
    value = value * -4.0*sqrt(gaussianExponentB)*gaussianExponentA/(gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == dxxyy)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5*((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)));
    value = value + gaussianExponentB*gaussianExponentB*dxyz(3)*dxyz(3)...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))...
        /gauPlusAB;
    value = value * 4.0*gaussianExponentA*gaussianExponentA*sqrt(gaussianExponentA)...
        *gaussianExponentB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.pz)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5*((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)));
    value = value + gaussianExponentA*gaussianExponentA*dxyz(3)*dxyz(3)...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))...
        /gauPlusAB;
    value = value * 4.0*gaussianExponentB*gaussianExponentB*sqrt(gaussianExponentB)...
        *gaussianExponentA/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.px && axis == 1 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.py && axis == 2 && valenceOrbitalB == dzz) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5...
        +2.0*gauMultAB*(dxyz(axis)*dxyz(axis))/gauPlusAB...
        +0.5*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gauMultAB*gauMultAB*dxyz(axis)*dxyz(axis)/(gauPlusAB*gauPlusAB))...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)));
    value = value * 4.0*sqrt(gaussianExponentA)*gaussianExponentB/(gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dzz && axis == 1 && valenceOrbitalB == OrbitalType.px) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 2 && valenceOrbitalB == OrbitalType.py) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5...
        +2.0*gauMultAB*(dxyz(axis)*dxyz(axis))/gauPlusAB...
        +0.5*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gauMultAB*gauMultAB*dxyz(axis)*dxyz(axis)/(gauPlusAB*gauPlusAB))...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)));
    value = value * 4.0*sqrt(gaussianExponentB)*gaussianExponentA/(gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.pz && axis == 3 && valenceOrbitalB == dzz)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 1.0...
        -4.0*gauMultAB*(dxyz(axis)*dxyz(axis))/gauPlusAB...
        +0.5*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gauMultAB*gauMultAB*dxyz(axis)*dxyz(axis)/(gauPlusAB*gauPlusAB))...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)));
    value = value * 4.0*sqrt(gaussianExponentA)*gaussianExponentB/(gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dzz && axis == 3 && valenceOrbitalB == OrbitalType.pz)
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 1.0...
        -4.0*gauMultAB*(dxyz(axis)*dxyz(axis))/gauPlusAB...
        +0.5*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gauMultAB*gauMultAB*dxyz(axis)*dxyz(axis)/(gauPlusAB*gauPlusAB))...
        *(2.0*(dxyz(3)*dxyz(3))-(dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)));
    value = value * 4.0*sqrt(gaussianExponentB)*gaussianExponentA/(gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxy && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 2 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 2 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 3 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 3 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 1 && valenceOrbitalB == valenceOrbitalA) )
    if(valenceOrbitalB == OrbitalType.dxy)
        if(axis == 1)
            anotherAxis = 2;
        else
            anotherAxis = 1;
        end
    elseif(valenceOrbitalB == OrbitalType.dyz)
        if(axis == 2)
            anotherAxis = 3;
        else
            anotherAxis = 2;
        end
    elseif(valenceOrbitalB == OrbitalType.dzx)
        if(axis == 3)
            anotherAxis = 1;
        else
            anotherAxis = 3;
        end
    end
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    gauMinsAB = gaussianExponentA-gaussianExponentB;
    value = 0.5*gauMinsAB*dxyz(axis)...
        +gauMinsAB*gauMultAB...
        *dxyz(axis)*(dxyz(anotherAxis)*dxyz(anotherAxis))/gauPlusAB;
    value = value * 8.0*gauMultAB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxy   && axis == 3 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dyz   && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dzx   && axis == 2 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == valenceOrbitalA) )
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == valenceOrbitalA) )
    if(axis == 1)
        anotherAxis = 2;
    else
        anotherAxis = 1;
    end
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    gauMinsAB = gaussianExponentA-gaussianExponentB;
    value = gauMinsAB*dxyz(axis)...
        -gauMinsAB*gauMultAB...
        *((dxyz(axis)*dxyz(axis)) - (dxyz(anotherAxis)*dxyz(anotherAxis)))*dxyz(axis)/gauPlusAB;
    value = value * 4.0*gauMultAB/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dzz && axis == 1 && valenceOrbitalB == valenceOrbitalA) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 2 && valenceOrbitalB == valenceOrbitalA) )
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    gauMinsAB = gaussianExponentA-gaussianExponentB;
    value = gauMinsAB*dxyz(axis)...
        -gauMinsAB*gauMultAB...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))*dxyz(axis)/gauPlusAB;
    value = value * 4.0*gauMultAB/(3.0*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( valenceOrbitalA == OrbitalType.dzz && axis == 3 && valenceOrbitalB == valenceOrbitalA)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    gauMinsAB = gaussianExponentA-gaussianExponentB;
    value = 2.0*gauMinsAB*dxyz(axis)...
        -gauMinsAB*gauMultAB...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))*dxyz(axis)/gauPlusAB;
    value = value * 8.0*gauMultAB/(3.0*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxy && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 3 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 1 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 2 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 1 && valenceOrbitalB == OrbitalType.dzx) )
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    gauMinsAB = gaussianExponentA-gaussianExponentB;
    value = -8.0*(gaussianExponentA*gauMultAB*gaussianExponentB)*dxyz(1)*dxyz(2)*dxyz(3)...
        *gauMinsAB/(gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
    
    
elseif( (valenceOrbitalA == OrbitalType.dxy && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 2 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 3 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 3 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 2 && valenceOrbitalB == OrbitalType.dzx) )
    if(valenceOrbitalA == OrbitalType.dxy && valenceOrbitalB == OrbitalType.dyz)
        anotherAxis1 = 2;
        anotherAxis2 = 3;
    elseif(valenceOrbitalA == OrbitalType.dyz && valenceOrbitalB == OrbitalType.dzx)
        anotherAxis1 = 3;
        anotherAxis2 = 1;
    elseif(valenceOrbitalA == OrbitalType.dzx && valenceOrbitalB == OrbitalType.dxy)
        anotherAxis1 = 1;
        anotherAxis2 = 2;
    elseif(valenceOrbitalA == OrbitalType.dyz && valenceOrbitalB == OrbitalType.dxy)
        anotherAxis1 = 2;
        anotherAxis2 = 1;
    elseif(valenceOrbitalA == OrbitalType.dzx && valenceOrbitalB == OrbitalType.dyz)
        anotherAxis1 = 3;
        anotherAxis2 = 2;
    elseif(valenceOrbitalA == OrbitalType.dxy && valenceOrbitalB == OrbitalType.dzx)
        anotherAxis1 = 1;
        anotherAxis2 = 3;
    end
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5-gauMultAB*dxyz(anotherAxis1)*dxyz(anotherAxis1)/gauPlusAB;
    value = value * 8.0*(gaussianExponentA*gaussianExponentA)*gaussianExponentB*dxyz(anotherAxis2)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dyz && axis == 1 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 3 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dyz && axis == 1 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 2 && valenceOrbitalB == OrbitalType.dxy) )
    if(valenceOrbitalA == OrbitalType.dyz && valenceOrbitalB == OrbitalType.dxy)
        anotherAxis1 = 2;
        anotherAxis2 = 3;
    elseif(valenceOrbitalA == OrbitalType.dzx && valenceOrbitalB == OrbitalType.dyz)
        anotherAxis1 = 3;
        anotherAxis2 = 1;
    elseif(valenceOrbitalA == OrbitalType.dxy && valenceOrbitalB == OrbitalType.dzx)
        anotherAxis1 = 1;
        anotherAxis2 = 2;
    elseif(valenceOrbitalA == OrbitalType.dxy && valenceOrbitalB == OrbitalType.dyz)
        anotherAxis1 = 2;
        anotherAxis2 = 1;
    elseif(valenceOrbitalA == OrbitalType.dyz && valenceOrbitalB == OrbitalType.dzx)
        anotherAxis1 = 3;
        anotherAxis2 = 2;
    elseif(valenceOrbitalA == OrbitalType.dzx && valenceOrbitalB == OrbitalType.dxy)
        anotherAxis1 = 1;
        anotherAxis2 = 3;
    end
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5-gauMultAB*dxyz(anotherAxis1)*dxyz(anotherAxis1)/gauPlusAB;
    value = value * -8.0*(gaussianExponentB*gaussianExponentB)*gaussianExponentA*dxyz(anotherAxis2)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.dxy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5*gauPlusAB...
        -(gaussianExponentA*gaussianExponentA)*gaussianExponentB*(dxyz(1)*dxyz(1))/gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(2.0*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(2)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxy && axis == 1 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5*gauPlusAB...
        -(gaussianExponentB*gaussianExponentB)*gaussianExponentA*(dxyz(1)*dxyz(1))/gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(2.0*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(2)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.dxy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5*gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB*(dxyz(2)*dxyz(2))/gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(2.0*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(1)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxy && axis == 2 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5*gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA*(dxyz(2)*dxyz(2))/gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(2.0*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(1)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.dxy) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 8.0*(gaussianExponentA*gaussianExponentA*gaussianExponentA*gaussianExponentA)...
        *(gaussianExponentB*gaussianExponentB*gaussianExponentB)...
        *dxyz(1)*dxyz(2)*dxyz(3)...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dyz && axis == 1 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 2 && valenceOrbitalB == dxxyy) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 3 && valenceOrbitalB == dxxyy) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -8.0*(gaussianExponentA*gaussianExponentA*gaussianExponentA)...
        *(gaussianExponentB*gaussianExponentB*gaussianExponentB*gaussianExponentB)...
        *dxyz(1)*dxyz(2)*dxyz(3)...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == OrbitalType.dyz)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5*gaussianExponentA...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB*(dxyz(2)*dxyz(2))/gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(2.0*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(3)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dyz && axis == 2 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5*gaussianExponentB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA*(dxyz(2)*dxyz(2))/gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/(2.0*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(3)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == OrbitalType.dzx)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5*gaussianExponentA...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB*(dxyz(1)*dxyz(1))/gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/(2.0*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(3)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dzx && axis == 1 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = -0.5*gaussianExponentB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA*(dxyz(2)*dxyz(2))/gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/(2.0*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(3)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.dyz)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gauMultAB*((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB+1.0;
    value = value * 4.0*gaussianExponentA*(gaussianExponentB*gaussianExponentB)*dxyz(2)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dyz && axis == 3 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gauMultAB*((dxyz(1)*dxyz(1))-(dxyz(2)*dxyz(2)))/gauPlusAB+1.0;
    value = value * -4.0*gaussianExponentB*(gaussianExponentA*gaussianExponentA)*dxyz(2)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == OrbitalType.dzx)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gauMultAB*((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/gauPlusAB+1.0;
    value = value * -4.0*gaussianExponentA*(gaussianExponentB*gaussianExponentB)*dxyz(1)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dzx && axis == 3 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gauMultAB*((dxyz(2)*dxyz(2))-(dxyz(1)*dxyz(1)))/gauPlusAB+1.0;
    value = value * 4.0*gaussianExponentB*(gaussianExponentA*gaussianExponentA)*dxyz(1)/(gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dzz && axis == 1 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 2 && valenceOrbitalB == OrbitalType.dzx) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 3 && valenceOrbitalB == OrbitalType.dxy) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2));
    value = value * dxyz(1)*dxyz(2)*dxyz(3);
    value = value * 8.0*(gaussianExponentA*gaussianExponentA*gaussianExponentA*gaussianExponentA)...
        *(gaussianExponentB*gaussianExponentB*gaussianExponentB);
    value = value / sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dyz && axis == 1 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 2 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 3 && valenceOrbitalB == dzz) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2));
    value = value * dxyz(1)*dxyz(2)*dxyz(3);
    value = value * -8.0*(gaussianExponentB*gaussianExponentB*gaussianExponentB*gaussianExponentB)*(gaussianExponentA*gaussianExponentA*gaussianExponentA);
    value = value / sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dzz && axis == 1 && valenceOrbitalB == OrbitalType.dxy) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 2 && valenceOrbitalB == OrbitalType.dxy) )
    if(axis == 1)
        anotherAxis = 2;
    elseif(axis == 2)
        anotherAxis = 1;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = 0.5*(gaussianExponentB-gaussianExponentA)...
        +3.0*(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *(dxyz(axis)*dxyz(axis))/(gauPlusAB*gauPlusAB)...
        +gaussianExponentA*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(2.0*gauPlusAB)...
        +(gaussianExponentA*gaussianExponentA*gaussianExponentA)*(gaussianExponentB*gaussianExponentB)*(dxyz(axis)*dxyz(axis))...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(anotherAxis)/(sqrt(3.0)*gauPlusAB*gauPlusAB*gauPlusAB);
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dxy && axis == 1 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.dxy && axis == 2 && valenceOrbitalB == dzz) )
    if(axis == 1)
        anotherAxis = 2;
    elseif(axis == 2)
        anotherAxis = 1;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    gauMinsAB = gaussianExponentA-gaussianExponentB;
    value = 0.5*gauMinsAB...
        +3.0*(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *(dxyz(axis)*dxyz(axis))/(gauPlusAB*gauPlusAB)...
        +gaussianExponentB*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(2.0*gauPlusAB)...
        +(gaussianExponentB*gaussianExponentB*gaussianExponentB)*(gaussianExponentA*gaussianExponentA)*(dxyz(axis)*dxyz(axis))...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(gauPlusAB*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(anotherAxis)/(sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB));
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dzz && axis == 2 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 1 && valenceOrbitalB == OrbitalType.dzx) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentB-0.5*gaussianExponentA...
        +gaussianExponentA*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(2.0*gauPlusAB)...
        +(gaussianExponentA*gaussianExponentA*gaussianExponentA)...
        *(gaussianExponentB*gaussianExponentB*dxyz(axis)*dxyz(axis))...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(3)...
        /(sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB));
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dyz && axis == 2 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 1 && valenceOrbitalB == dzz) )
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentA-0.5*gaussianExponentB...
        +gaussianExponentB*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(2.0*gauPlusAB)...
        +(gaussianExponentB*gaussianExponentB*gaussianExponentB)*(gaussianExponentA*gaussianExponentA*dxyz(axis)*dxyz(axis))...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(3)...
        /(sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB));
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dzz && axis == 3 && valenceOrbitalB == OrbitalType.dyz) ||...
        (valenceOrbitalA == OrbitalType.dzz && axis == 3 && valenceOrbitalB == OrbitalType.dzx) )
    if(valenceOrbitalB == OrbitalType.dyz)
        anotherAxis = 2;
    elseif(valenceOrbitalB == OrbitalType.dzx)
        anotherAxis = 1;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentA-0.5*gaussianExponentB...
        -3.0*(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *dxyz(axis)*dxyz(axis)/(gauPlusAB*gauPlusAB)...
        +gaussianExponentA*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(2.0*gauPlusAB)...
        +(gaussianExponentA*gaussianExponentA*gaussianExponentA)...
        *(gaussianExponentB*gaussianExponentB*dxyz(axis)*dxyz(axis))...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB);
    value = value * 8.0*gauMultAB*dxyz(anotherAxis)...
        /(sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB));
    value = value * overlapSASB;
    value = value + xyzB(axis)*overlapAOs1;
elseif( (valenceOrbitalA == OrbitalType.dyz && axis == 3 && valenceOrbitalB == dzz) ||...
        (valenceOrbitalA == OrbitalType.dzx && axis == 3 && valenceOrbitalB == dzz) )
    if(valenceOrbitalA == OrbitalType.dyz)
        anotherAxis = 2;
    elseif(valenceOrbitalA == OrbitalType.dzx)
        anotherAxis = 1;
    end
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentB-0.5*gaussianExponentA...
        -3.0*(gaussianExponentB*gaussianExponentB)*gaussianExponentA*dxyz(axis)*dxyz(axis)/(gauPlusAB*gauPlusAB)...
        +gaussianExponentB*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/(2.0*gauPlusAB)...
        +(gaussianExponentB*gaussianExponentB*gaussianExponentB)...
        *(gaussianExponentA*gaussianExponentA*dxyz(axis)*dxyz(axis))...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))...
        /(gauPlusAB*gauPlusAB);
    value = value * -8.0*gauMultAB*dxyz(anotherAxis)...
        /(sqrt(3.0)*(gauPlusAB*gauPlusAB*gauPlusAB));
    value = value * overlapSASB;
    value = value + xyzA(axis)*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dzz && axis == 1 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentB - gaussianExponentA...
        +gaussianExponentA*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *((dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/gauPlusAB;
    value = value * 4.0*gauMultAB*dxyz(1)/(gauPlusAB*gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 1 && valenceOrbitalB == dzz)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentA - gaussianExponentB...
        +gaussianExponentB*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *((dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/gauPlusAB;
    value = value * -4.0*gauMultAB*dxyz(1)/(gauPlusAB*gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dzz && axis == 2 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentB - gaussianExponentA...
        +gaussianExponentA*(gaussianExponentB*gaussianExponentB)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gaussianExponentA*gaussianExponentA)*gaussianExponentB...
        *((dxyz(2)*dxyz(2)) - (dxyz(1)*dxyz(1)))/gauPlusAB;
    value = value * -4.0*gauMultAB*dxyz(2)/(gauPlusAB*gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 2 && valenceOrbitalB == dzz)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = gaussianExponentA - gaussianExponentB...
        +gaussianExponentB*(gaussianExponentA*gaussianExponentA)...
        *(2.0*(dxyz(3)*dxyz(3)) - (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2)))/gauPlusAB...
        +(gaussianExponentB*gaussianExponentB)*gaussianExponentA...
        *((dxyz(2)*dxyz(2)) - (dxyz(1)*dxyz(1)))/gauPlusAB;
    value = value * 4.0*gauMultAB*dxyz(2)/(gauPlusAB*gauPlusAB*gauPlusAB*sqrt(3.0));
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dzz && axis == 3 && valenceOrbitalB == dxxyy)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2));
    value = value * -8.0*(gaussianExponentA*gaussianExponentA*gaussianExponentA)*(gaussianExponentB*gaussianExponentB)*dxyz(3);
    value = value / sqrt(3.0)*gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB;
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
elseif(valenceOrbitalA == OrbitalType.dxxyy && axis == 3 && valenceOrbitalB == dzz)
    axisAverage = (gaussianExponentA*xyzA(axis)+gaussianExponentB*xyzB(axis))/gauPlusAB;
    overlapAOs1 = obj.GetGaussianOverlapAOs(atomTypeA,...
        valenceOrbitalA, ...
        gaussianExponentA, ...
        atomTypeB, ...
        valenceOrbitalB, ...
        gaussianExponentB,...
        dxyz, ...
        rAB,...
        overlapSASB);
    value = (dxyz(1)*dxyz(1)) - (dxyz(2)*dxyz(2));
    value = value * 8.0*(gaussianExponentA*gaussianExponentA)*(gaussianExponentB*gaussianExponentB*gaussianExponentB)*dxyz(3);
    value = value / sqrt(3.0)*gauPlusAB*gauPlusAB*gauPlusAB*gauPlusAB;
    value = value * overlapSASB;
    value = value + axisAverage*overlapAOs1;
else
    throw(MException('Cndo2:GetGaussianCartesianMatrix', 'Orbital type wrong.'));
end

end